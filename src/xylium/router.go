package xylium

import (
	"encoding/json" // For ServeFiles PathNotFound JSON response.
	"fmt"           // For error formatting.
	"io"            // For HTMLRenderer interface and io.Closer.
	"os"            // For os.Stdout in logger config adjustments (NewWithConfig).
	"path/filepath" // For path cleaning and manipulation in ServeFiles.
	"runtime/debug" // For capturing stack traces on panic.
	"strings"       // For string manipulation (path normalization, joining).
	"sync"          // For sync.RWMutex and sync.Mutex.

	"github.com/valyala/fasthttp" // The underlying HTTP engine.
)

// HTMLRenderer defines the interface for HTML template rendering.
// Applications can implement this interface to integrate their preferred
// HTML templating engine (e.g., html/template, pongo2) with Xylium.
type HTMLRenderer interface {
	// Render writes the output of a template to the provided io.Writer.
	// 'name' is the template name, 'data' is the data to pass to the template,
	// and 'c' is the Xylium Context for potential access to request-specific info.
	Render(w io.Writer, name string, data interface{}, c *Context) error
}

// Router is the main request router for the Xylium framework.
// It manages route registration, middleware execution, request handling,
// error processing, server configuration, and application-level shared resources.
type Router struct {
	tree             *Tree        // Radix tree for efficient route matching.
	globalMiddleware []Middleware // Middleware applied to all routes.

	// PanicHandler is invoked when a panic is recovered during request processing.
	// If not set, a default handler is used (see defaultPanicHandler).
	PanicHandler HandlerFunc
	// NotFoundHandler is invoked when no route matches the requested path.
	// If not set, a default handler is used (see defaultNotFoundHandler).
	NotFoundHandler HandlerFunc
	// MethodNotAllowedHandler is invoked when a route matches the path but not the HTTP method.
	// If not set, a default handler is used (see defaultMethodNotAllowedHandler).
	MethodNotAllowedHandler HandlerFunc
	// GlobalErrorHandler is the central handler for all errors returned by route handlers
	// or middleware, and for errors generated by the PanicHandler.
	// If not set, a default handler is used (see defaultGlobalErrorHandler).
	GlobalErrorHandler HandlerFunc

	serverConfig ServerConfig // Configuration for the underlying fasthttp.Server.
	HTMLRenderer HTMLRenderer // Optional HTML template renderer.
	instanceMode string       // Operating mode (e.g., "debug", "release") of this router instance.

	// appStore holds application-level shared data (e.g., service instances, configurations).
	// Access is protected by appStoreMux.
	appStore map[string]interface{}
	// appStoreMux protects concurrent access to appStore.
	appStoreMux sync.RWMutex

	// closers stores io.Closer instances that need to be closed during graceful shutdown.
	// This includes resources set via AppSet that implement io.Closer.
	// Access is protected by closersMux.
	closers []io.Closer
	// closersMux protects concurrent access to the closers slice.
	closersMux sync.Mutex

	// internalRateLimitStores stores LimiterStore instances created internally by Xylium
	// (e.g., default InMemoryStore for RateLimiter middleware) that require closing on shutdown.
	internalRateLimitStores []LimiterStore
	// internalRateLimitStoresMux protects internalRateLimitStores.
	internalRateLimitStoresMux sync.Mutex
}

// Logger returns the configured logger for this router instance.
// This logger is automatically configured (level, color, caller info) based on
// Xylium's operating mode during router initialization if it's a DefaultLogger.
// If a custom logger is provided via ServerConfig, that logger is returned as is.
func (r *Router) Logger() Logger {
	// serverConfig.Logger is guaranteed to be non-nil by NewWithConfig.
	return r.serverConfig.Logger
}

// New creates a new Router instance with default server configuration.
// The logger will be automatically configured based on the Xylium operating mode.
func New() *Router {
	return NewWithConfig(DefaultServerConfig())
}

// NewWithConfig creates a new Router instance with the provided ServerConfig.
// It performs crucial initialization steps, including mode determination, logger setup,
// default handler assignments, and initialization of internal stores.
func NewWithConfig(config ServerConfig) *Router {
	updateGlobalModeFromEnvOnRouterInit() // Ensure mode is up-to-date with .env files etc.
	effectiveMode := Mode()               // Get the final effective mode for this router instance.

	// Logger initialization and configuration
	if config.Logger == nil {
		baseLogCfg := DefaultLoggerConfig() // Start with Xylium's defaults
		if config.LoggerConfig != nil {     // If user provided LoggerConfig, merge it
			userProvidedLogCfg := *config.LoggerConfig
			if userProvidedLogCfg.Output != nil {
				baseLogCfg.Output = userProvidedLogCfg.Output
			}
			if userProvidedLogCfg.Formatter != "" {
				baseLogCfg.Formatter = userProvidedLogCfg.Formatter
			}
			// Level, ShowCaller, UseColor are explicitly set below based on mode,
			// but user's LoggerConfig takes precedence if they set it directly.
			// We'll re-apply user's preferences after mode-based defaults.
		}

		// Apply mode-based defaults first
		finalLogCfg := baseLogCfg
		switch effectiveMode {
		case DebugMode:
			finalLogCfg.Level = LevelDebug
			finalLogCfg.ShowCaller = true
			finalLogCfg.UseColor = true // Enable color by default in DebugMode
		case TestMode:
			finalLogCfg.Level = LevelDebug
			finalLogCfg.ShowCaller = true
			finalLogCfg.UseColor = false // No color for tests
		case ReleaseMode:
			finalLogCfg.Level = LevelInfo
			finalLogCfg.ShowCaller = false
			finalLogCfg.UseColor = false
		}

		// If LoggerConfig was provided by user, let its specific settings override mode-based ones.
		if config.LoggerConfig != nil {
			userProvidedLogCfg := *config.LoggerConfig
			// Override level if explicitly set in LoggerConfig
			if userProvidedLogCfg.Level != DefaultLoggerConfig().Level { // Check if it was changed from default
				finalLogCfg.Level = userProvidedLogCfg.Level
			}
			// Override ShowCaller if explicitly set
			if userProvidedLogCfg.ShowCaller != DefaultLoggerConfig().ShowCaller {
				finalLogCfg.ShowCaller = userProvidedLogCfg.ShowCaller
			}
			// Override UseColor if explicitly set
			if userProvidedLogCfg.UseColor != DefaultLoggerConfig().UseColor {
				finalLogCfg.UseColor = userProvidedLogCfg.UseColor
			}
			// Formatter and Output are already taken from baseLogCfg which merged LoggerConfig.
		}

		// Ensure Output is not nil (defaults to os.Stdout if still nil).
		if finalLogCfg.Output == nil {
			finalLogCfg.Output = os.Stdout
		}
		config.Logger = NewDefaultLoggerWithConfig(finalLogCfg)
		config.Logger.Debugf("Router using DefaultLogger, configured. EffectiveMode: %s, FinalLoggerConfig: %+v", effectiveMode, finalLogCfg)
	} else {
		config.Logger.Warnf(
			"A custom logger (type: %T) was provided. Automatic Xylium mode-based and LoggerConfig-based logger configuration is skipped.",
			config.Logger,
		)
	}

	// Initialize the router instance.
	routerInstance := &Router{
		tree:                    NewTree(),
		globalMiddleware:        make([]Middleware, 0),
		serverConfig:            config,
		instanceMode:            effectiveMode,
		appStore:                make(map[string]interface{}),
		closers:                 make([]io.Closer, 0),
		internalRateLimitStores: make([]LimiterStore, 0),
	}

	// Set default handlers for common framework events.
	routerInstance.NotFoundHandler = defaultNotFoundHandler
	routerInstance.MethodNotAllowedHandler = defaultMethodNotAllowedHandler
	routerInstance.PanicHandler = defaultPanicHandler
	routerInstance.GlobalErrorHandler = defaultGlobalErrorHandler

	routerInstance.Logger().Infof("Xylium Router initialized (Adopting Mode: %s, Determined By: %s)", routerInstance.instanceMode, modeSource)
	return routerInstance
}

// CurrentMode returns the operating mode of this specific router instance.
func (r *Router) CurrentMode() string {
	return r.instanceMode
}

// Use adds global middleware(s) to the router's chain.
// These middleware will be executed for every request handled by this router.
func (r *Router) Use(middlewares ...Middleware) {
	r.globalMiddleware = append(r.globalMiddleware, middlewares...)
}

// AppSet stores a key-value pair in the application-level store.
// This store is shared across all requests handled by this router instance,
// making it suitable for storing shared services, configurations, or connection pools.
// If the provided `value` implements the `io.Closer` interface, it is automatically
// registered via `RegisterCloser` to be closed during the router's graceful shutdown.
// This method is thread-safe.
func (r *Router) AppSet(key string, value interface{}) {
	r.appStoreMux.Lock()
	r.appStore[key] = value
	r.appStoreMux.Unlock()

	if closer, ok := value.(io.Closer); ok {
		r.RegisterCloser(closer)
	}
}

// AppGet retrieves a value from the application-level store by its key.
// Returns the value and true if the key exists, otherwise nil and false.
// This method is thread-safe.
func (r *Router) AppGet(key string) (interface{}, bool) {
	r.appStoreMux.RLock()
	defer r.appStoreMux.RUnlock()
	if r.appStore == nil { // Defensive check, though initialized in NewWithConfig.
		return nil, false
	}
	val, ok := r.appStore[key]
	return val, ok
}

// RegisterCloser explicitly registers an `io.Closer` instance to be closed
// during the router's graceful shutdown sequence.
// This is useful for managing the lifecycle of resources that are not stored
// in the `AppStore` but still need cleanup (e.g., a global logger file,
// a background worker pool).
// If the provided `closer` is nil, the method does nothing.
// This method is thread-safe.
func (r *Router) RegisterCloser(closer io.Closer) {
	if closer == nil {
		return
	}
	r.closersMux.Lock()
	defer r.closersMux.Unlock()
	// Optional: Check for duplicates if necessary and feasible.
	r.closers = append(r.closers, closer)
	r.Logger().Debugf("Resource (type %T) explicitly registered for graceful shutdown.", closer)
}

// addInternalStore registers an internally created LimiterStore with the router.
// This method is unexported and intended for internal framework use (e.g., by RateLimiter middleware
// when it creates its own default InMemoryStore).
// It ensures these internal stores are closed during graceful shutdown.
// This method is thread-safe.
func (r *Router) addInternalStore(store LimiterStore) {
	if store == nil {
		return
	}
	r.internalRateLimitStoresMux.Lock()
	defer r.internalRateLimitStoresMux.Unlock()

	// Check for duplicates to avoid multiple registrations of the same store instance.
	for _, existingStore := range r.internalRateLimitStores {
		if existingStore == store {
			r.Logger().Debugf("Internal LimiterStore (type %T) already registered; registration skipped.", store)
			return
		}
	}
	r.internalRateLimitStores = append(r.internalRateLimitStores, store)
	r.Logger().Debugf("Internally created LimiterStore (type %T) registered for graceful shutdown.", store)
}

// addRoute is an internal helper to register a new route.
// It normalizes the path and associates the handler and route-specific middleware.
func (r *Router) addRoute(method, path string, handler HandlerFunc, middlewares ...Middleware) {
	if path == "" {
		path = "/" // Default to root path if empty.
	}
	if path[0] != '/' {
		panic(fmt.Sprintf("xylium: path must begin with '/' (e.g., \"/users\" or \"/\"), got \"%s\"", path))
	}
	// `Tree.Add` will handle further normalization like trailing slashes.
	r.tree.Add(method, path, handler, middlewares...)
}

// GET registers a new GET request handler with the given path.
func (r *Router) GET(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodGet, path, handler, middlewares...)
}

// POST registers a new POST request handler with the given path.
func (r *Router) POST(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodPost, path, handler, middlewares...)
}

// PUT registers a new PUT request handler with the given path.
func (r *Router) PUT(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodPut, path, handler, middlewares...)
}

// DELETE registers a new DELETE request handler with the given path.
func (r *Router) DELETE(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodDelete, path, handler, middlewares...)
}

// PATCH registers a new PATCH request handler with the given path.
func (r *Router) PATCH(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodPatch, path, handler, middlewares...)
}

// HEAD registers a new HEAD request handler with the given path.
func (r *Router) HEAD(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodHead, path, handler, middlewares...)
}

// OPTIONS registers a new OPTIONS request handler with the given path.
func (r *Router) OPTIONS(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodOptions, path, handler, middlewares...)
}

// Handler is the core fasthttp.RequestHandlerFunc for the Xylium router.
// It is passed to the fasthttp.Server. It acquires a Xylium Context, finds the
// appropriate route, executes middleware and the handler, and manages error/panic recovery.
func (r *Router) Handler(originalFasthttpCtx *fasthttp.RequestCtx) {
	c := acquireCtx(originalFasthttpCtx)
	c.setRouter(r)
	defer releaseCtx(c)

	var errHandler error
	requestScopedLogger := c.Logger()

	defer func() {
		if rec := recover(); rec != nil {
			requestScopedLogger.Errorf("PANIC RECOVERED: %v\n%s", rec, string(debug.Stack()))
			if r.PanicHandler != nil {
				c.Set(ContextKeyPanicInfo, rec) // Use defined constant
				errHandler = r.PanicHandler(c)
			} else { // Should not be reached if defaults are set
				errHandler = NewHTTPError(StatusInternalServerError, "Internal server error due to panic.").WithInternal(fmt.Errorf("panic: %v", rec)) //nolint:goerr113
			}
		}

		if errHandler != nil {
			if !c.ResponseCommitted() {
				if r.GlobalErrorHandler != nil {
					c.Set(ContextKeyErrorCause, errHandler) // Use defined constant
					if globalErrHandlingErr := r.GlobalErrorHandler(c); globalErrHandlingErr != nil {
						requestScopedLogger.Errorf("CRITICAL: Error within GlobalErrorHandler: %v (while handling original error: %v)", globalErrHandlingErr, errHandler)
						c.Ctx.Response.SetStatusCode(StatusInternalServerError)
						c.Ctx.Response.SetBodyString("Internal Server Error - Critical error handler failure") // More specific
						c.Ctx.Response.Header.SetContentType("text/plain; charset=utf-8")
					}
				} else { // Should not be reached if defaults are set
					requestScopedLogger.Errorf("CRITICAL: GlobalErrorHandler is nil. Error: %v for %s %s. Sending raw 500.", errHandler, c.Method(), c.Path())
					c.Ctx.Response.SetStatusCode(StatusInternalServerError)
					c.Ctx.Response.SetBodyString("Internal Server Error - No global error handler configured")
					c.Ctx.Response.Header.SetContentType("text/plain; charset=utf-8")
				}
			} else {
				requestScopedLogger.Warnf("Response already committed, but an error was generated post-commitment: %v for %s %s. This error cannot be sent to client.", errHandler, c.Method(), c.Path())
			}
		} else if !c.ResponseCommitted() && c.Method() != MethodHead {
			statusCode := c.Ctx.Response.StatusCode()
			isNoContentStatus := (statusCode == StatusNoContent || statusCode == StatusNotModified)
			// Check if body is truly empty or ContentLength explicitly set to 0.
			// fasthttp sets ContentLength to -1 if not specified and body is empty.
			isResponseEffectivelyEmpty := (len(c.Ctx.Response.Body()) == 0 && (c.Ctx.Response.Header.ContentLength() == 0 || c.Ctx.Response.Header.ContentLength() == -1))

			if !isNoContentStatus && isResponseEffectivelyEmpty && statusCode < StatusBadRequest {
				if r.CurrentMode() == DebugMode {
					requestScopedLogger.Debugf(
						"Handler for %s %s completed without sending response body or explicit c.NoContent() (Status: %d). Ensure handlers always send a response.",
						c.Method(), c.Path(), statusCode,
					)
				}
			}
		}
	}()

	method := c.Method()
	path := c.Path()
	nodeHandler, routeMiddleware, params, allowedMethods := r.tree.Find(method, path)

	if nodeHandler != nil {
		c.Params = params
		finalChain := nodeHandler
		for i := len(routeMiddleware) - 1; i >= 0; i-- {
			finalChain = routeMiddleware[i](finalChain)
		}
		for i := len(r.globalMiddleware) - 1; i >= 0; i-- {
			finalChain = r.globalMiddleware[i](finalChain)
		}
		c.handlers = []HandlerFunc{finalChain}
		c.index = -1
		errHandler = c.Next()
	} else {
		if len(allowedMethods) > 0 {
			c.Params = params
			if r.MethodNotAllowedHandler != nil {
				c.SetHeader("Allow", strings.Join(allowedMethods, ", "))
				errHandler = r.MethodNotAllowedHandler(c)
			} else { // Should use default
				errHandler = NewHTTPError(StatusMethodNotAllowed, StatusText(StatusMethodNotAllowed))
			}
		} else {
			if r.NotFoundHandler != nil {
				errHandler = r.NotFoundHandler(c)
			} else { // Should use default
				errHandler = NewHTTPError(StatusNotFound, StatusText(StatusNotFound))
			}
		}
	}
}

// ServeFiles serves static files from a given filesystem root directory under a specified URL prefix.
//
// Parameters:
//   - urlPathPrefix: The URL path prefix under which files will be served.
//     Example: "/static" means requests to "/static/css/style.css" are handled.
//     If serving from root, use "/" or "".
//   - fileSystemRoot: The absolute or relative path to the directory on the server's
//     filesystem containing the static files.
//
// Panics if `urlPathPrefix` contains route parameters (':' or '*') or if `fileSystemRoot` is invalid.
// It uses `fasthttp.FS` for efficient file serving.
func (r *Router) ServeFiles(urlPathPrefix string, fileSystemRoot string) {
	if strings.Contains(urlPathPrefix, ":") || strings.Contains(urlPathPrefix, "*") {
		panic("xylium: urlPathPrefix for ServeFiles cannot contain route parameters ':' or '*'")
	}

	cleanedFileSystemRoot, err := filepath.Abs(filepath.Clean(fileSystemRoot))
	if err != nil {
		panic(fmt.Sprintf("xylium: ServeFiles could not determine absolute path for fileSystemRoot '%s': %v", fileSystemRoot, err))
	}
	if _, statErr := os.Stat(cleanedFileSystemRoot); os.IsNotExist(statErr) {
		r.Logger().Warnf("ServeFiles: The specified fileSystemRoot directory '%s' (resolved to '%s') does not exist. Static file serving for '%s' might not work as expected.",
			fileSystemRoot, cleanedFileSystemRoot, urlPathPrefix)
	}

	normalizedUrlPathPrefix := "/" + strings.Trim(urlPathPrefix, "/")
	if urlPathPrefix == "/" || urlPathPrefix == "" {
		normalizedUrlPathPrefix = "/"
	}

	catchAllParamName := "filepath"
	routePath := ""
	if normalizedUrlPathPrefix == "/" {
		routePath = "/*" + catchAllParamName
	} else {
		routePath = normalizedUrlPathPrefix + "/*" + catchAllParamName
	}

	routerBaseLogger := r.Logger()
	fs := &fasthttp.FS{
		Root:               cleanedFileSystemRoot,
		IndexNames:         []string{"index.html"},
		GenerateIndexPages: false,
		AcceptByteRange:    true,
		Compress:           true,
		PathNotFound: func(originalFasthttpCtx *fasthttp.RequestCtx) {
			errorMsg := M{"error": "The requested static asset was not found."}
			assetPath := string(originalFasthttpCtx.Path())

			// Use a logger derived from the router's base logger for PathNotFound,
			// as this callback doesn't have a full Xylium Context.
			fsLogger := routerBaseLogger
			if fsLogger == nil { // Extremely defensive, router.Logger() should always be valid.
				fsLogger = NewDefaultLogger()
			}

			fsLogger.Warnf(
				"ServeFiles: Static asset not found by fasthttp.FS. URI: %s, FS Attempted Path: %s, FS Root: %s",
				string(originalFasthttpCtx.RequestURI()), assetPath, cleanedFileSystemRoot,
			)

			originalFasthttpCtx.SetStatusCode(StatusNotFound)
			originalFasthttpCtx.SetContentType("application/json; charset=utf-8")
			if err := json.NewEncoder(originalFasthttpCtx.Response.BodyWriter()).Encode(errorMsg); err != nil {
				fsLogger.Errorf(
					"ServeFiles: CRITICAL - Error encoding JSON for PathNotFound (asset path: %s): %v.",
					assetPath, err,
				)
			}
		},
	}
	fileServerHandler := fs.NewRequestHandler()

	r.GET(routePath, func(c *Context) error {
		requestedFileSubPath := c.Param(catchAllParamName)
		pathForFasthttpFS := "/" + filepath.Clean("/"+requestedFileSubPath)
		originalURI := c.Ctx.Request.RequestURI()
		c.Ctx.Request.SetRequestURI(pathForFasthttpFS)
		fileServerHandler(c.Ctx)
		c.Ctx.Request.SetRequestURIBytes(originalURI)
		return nil
	})
	r.Logger().Debugf("Static file serving configured for URL prefix '%s' from filesystem root '%s' via route '%s'",
		normalizedUrlPathPrefix, cleanedFileSystemRoot, routePath)
}

// RouteGroup allows organizing routes under a common path prefix and/or shared middleware.
type RouteGroup struct {
	router     *Router
	prefix     string
	middleware []Middleware
}

// Group creates a new RouteGroup with the given URL prefix and optional group-level middleware.
func (r *Router) Group(urlPrefix string, middlewares ...Middleware) *RouteGroup {
	normalizedPrefix := "/" + strings.Trim(urlPrefix, "/")
	if urlPrefix == "/" || urlPrefix == "" {
		normalizedPrefix = "/"
	}
	groupMiddleware := make([]Middleware, len(middlewares))
	copy(groupMiddleware, middlewares)

	return &RouteGroup{
		router:     r,
		prefix:     normalizedPrefix,
		middleware: groupMiddleware,
	}
}

// Use adds middleware to the RouteGroup.
func (rg *RouteGroup) Use(middlewares ...Middleware) {
	rg.middleware = append(rg.middleware, middlewares...)
}

// addRoute is an internal helper for RouteGroup to register a route.
func (rg *RouteGroup) addRoute(method, relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	normalizedRelativePath := "/" + strings.Trim(relativePath, "/")
	if relativePath == "/" || relativePath == "" {
		normalizedRelativePath = "/"
	}

	var fullPath string
	if rg.prefix == "/" {
		if normalizedRelativePath == "/" {
			fullPath = "/"
		} else {
			fullPath = normalizedRelativePath
		}
	} else {
		if normalizedRelativePath == "/" {
			fullPath = rg.prefix
		} else {
			fullPath = rg.prefix + normalizedRelativePath
		}
	}

	allApplicableMiddleware := make([]Middleware, 0, len(rg.middleware)+len(middlewares))
	allApplicableMiddleware = append(allApplicableMiddleware, rg.middleware...)
	allApplicableMiddleware = append(allApplicableMiddleware, middlewares...)

	rg.router.addRoute(method, fullPath, handler, allApplicableMiddleware...)
}

// GET registers a new GET request handler within the route group.
func (rg *RouteGroup) GET(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodGet, relativePath, handler, middlewares...)
}

// POST registers a new POST request handler within the route group.
func (rg *RouteGroup) POST(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodPost, relativePath, handler, middlewares...)
}

// PUT registers a new PUT request handler within the route group.
func (rg *RouteGroup) PUT(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodPut, relativePath, handler, middlewares...)
}

// DELETE registers a new DELETE request handler within the route group.
func (rg *RouteGroup) DELETE(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodDelete, relativePath, handler, middlewares...)
}

// PATCH registers a new PATCH request handler within the route group.
func (rg *RouteGroup) PATCH(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodPatch, relativePath, handler, middlewares...)
}

// HEAD registers a new HEAD request handler within the route group.
func (rg *RouteGroup) HEAD(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodHead, relativePath, handler, middlewares...)
}

// OPTIONS registers a new OPTIONS request handler within the route group.
func (rg *RouteGroup) OPTIONS(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodOptions, relativePath, handler, middlewares...)
}

// Group creates a new sub-RouteGroup nested within the current group.
func (rg *RouteGroup) Group(relativePathPrefix string, middlewares ...Middleware) *RouteGroup {
	normalizedRelativePrefix := "/" + strings.Trim(relativePathPrefix, "/")
	if relativePathPrefix == "/" || relativePathPrefix == "" {
		normalizedRelativePrefix = "/"
	}

	var newFullPrefix string
	if rg.prefix == "/" {
		if normalizedRelativePrefix == "/" {
			newFullPrefix = "/"
		} else {
			newFullPrefix = normalizedRelativePrefix
		}
	} else {
		if normalizedRelativePrefix == "/" {
			newFullPrefix = rg.prefix
		} else {
			newFullPrefix = rg.prefix + normalizedRelativePrefix
		}
	}

	combinedMiddleware := make([]Middleware, 0, len(rg.middleware)+len(middlewares))
	combinedMiddleware = append(combinedMiddleware, rg.middleware...)
	combinedMiddleware = append(combinedMiddleware, middlewares...)

	return &RouteGroup{
		router:     rg.router,
		prefix:     newFullPrefix,
		middleware: combinedMiddleware,
	}
}
